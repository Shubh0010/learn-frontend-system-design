
# Cross-Site Scripting (CORS)

Cross-Site Scripting (XSS) refers to a security vulnerability where an attacker injects malicious scripts into a website, allowing them to execute unauthorized actions and potentially compromise sensitive data.

---

# Vulnerabilities
  
  1. User Session Hijacking:
      
    Attackers can steal session cookies, allowing them to impersonate users and access their accounts without authorization.
    
  2. Unauthorized Activities:

    Hackers may perform actions on behalf of users without their consent, such as making unauthorized transactions or modifying account settings.

  3. Keystroke Capture:

    Malicious scripts can capture keystrokes entered by users, enabling attackers to collect sensitive information such as passwords and credit card details.

  4. Stealing Critical Information:

    Attackers can extract sensitive data from the user interface, such as screenshots or the Document Object Model (DOM), which may contain confidential information.

  5. Phishing Attacks:

    By embedding phishing forms or scripts in legitimate websites, attackers can trick users into divulging sensitive information, such as login credentials or personal details.

  `Remarks: Hacker will identify Vulnerabilities, for example, a param that is directly used in innerHTML, and than can use that param to send data to their site.`

---

# Mitigation

1. List all possible ways to take user inputs: This step involves identifying all the entry points where user inputs are accepted within the application, including form fields, URL parameters, HTTP headers, etc. This is an important first step in understanding where vulnerabilities may exist.

2. Use innerText instead of innerHTML: Using innerText instead of innerHTML can help prevent XSS attacks by ensuring that any user-supplied content is treated as plain text rather than HTML markup. However, this approach may not always be feasible depending on the requirements of the application.

3. Use Escaping: Escaping user input involves encoding special characters such as <, >, &, etc., so that they are interpreted as literal characters rather than HTML or JavaScript code. This prevents browsers from interpreting user input as executable code.

4. Using Libraries like React, etc.: Frameworks like React often provide built-in protections against XSS attacks by automatically escaping user input in JSX expressions. However, it's important to use these frameworks properly and keep them up to date to ensure the latest security features are utilized.

5. Sanitize user input data using libraries like DOMPurify: DOMPurify is a library specifically designed for sanitizing HTML and preventing XSS attacks by removing potentially dangerous content from user inputs while allowing safe content to pass through.

6. CSP (Content Security Policy) Headers:

  6.1. Decide allowed resources: Content Security Policy allows you to define which resources (e.g., scripts, stylesheets, images) the browser is allowed to load, thereby reducing the risk of XSS attacks by limiting the sources from which content can be loaded.

  6.2. Script Nonces: CSP allows you to specify a nonce (number used once) for each script tag, and the browser will only execute scripts with matching nonces. This ensures that only scripts generated by the server with the correct nonce are executed, mitigating the risk of injected malicious scripts.

  6.3. Report-only-mode: CSP can be configured in report-only mode initially to monitor policy violations without enforcing them. This helps in identifying potential issues before fully enforcing the CSP policy.

7. Avoid using eval()